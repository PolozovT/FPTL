#include <boost/spirit/include/lex.hpp>
#include <boost/spirit/include/lex_lexertl.hpp>

namespace lex = boost::spirit::lex;


void f1()
	{
	}

	void f2()
	{
	}

	void f3()
	{
	}

	void f4()
	{
	}

	template< typename Lexer >
	struct SScanner : lex::lexer<Lexer>
	{
		SScanner()
		{
			this->self.add_pattern( "{Exp}", "[eE][+-]?[0-9]+" );

			// Инициализация правил.
			White = "[ \t\r]";
			NewLine = "\n";
			ShortComment = "\"/\"\"*\"(.|\n)*\"*\"\"/\"";
			CommentBlock = "f";

			this->self = White[f1] | NewLine[f2] | ShortComment[f3] | CommentBlock[f4];
		}

		lex::token_def<> White, NewLine, ShortComment, CommentBlock;
	};

	void Test()
	{
		typedef lex::lexertl::token<char*, lex::omit, boost::mpl::false_> token_type;
		typedef lex::lexertl::actor_lexer<token_type> lexer_type;

		SScanner<lexer_type> Lexer;

		char *Str = " /*d\na*/ dsdsdasdsdsdaaaaaadsddsaaa";

		bool r = lex::tokenize( Str, Str+15, Lexer );
	}

	class BoostScanner
	{
	public:

		BoostScanner( char * aInputString )
		{
			mIter = mScanner.begin( aInputString, aInputString + strlen(aInputString) + 2 );
			mEnd = mScanner.end();
		}

		int GetToken()
		{
			if( mIter != mEnd )
			{
				if( token_is_valid(*mIter) )
				{
					++mIter;
				}
				else
				{
					// Error.
				}
			}
			else
				return 0;
		}

	private:

		typedef lex::lexertl::token<char*, lex::omit, boost::mpl::false_> TTokenType;
		typedef lex::lexertl::actor_lexer<TTokenType> TLexerType;
		TLexerType::iterator_type mIter;
		TLexerType::iterator_type mEnd;

		SScanner<TLexerType> mScanner;
	};