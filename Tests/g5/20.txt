Data List['t]
{
	List = c_nil ++ 't * List['t].c_cons;
}

Scheme ShortestPath
{
	//@=[1].read.[3].create_vector.print;
	//@=[1].read.([1]*[3]).Floyd.[2].print;
	@=(([1].read.([1]*[3]).Floyd.([2]*[3]).id)*[2]*[3]).find.print;
	
		
	//арность 3->1
	//ищет кратчайший путь в матрице [1] размером [3]*[3] из [2] в [3]
	find = ([1] * [2] * [3] * [4] * [4]).find2;
	
    //арность 5->1
	//вспомогательная функция поиска пути по матрице [1] размером [2] из вершины [3] в вершину [4] через [5]
	find2 = ([5] * [3]).equal -> ([3] * c_nil).c_cons,
					([5] * ([1] * [2] * [3] * [4]* ([1] * ([3] * [5] * [2]).IJ).getElem ).find2).c_cons;				
	
	//арность 2->2
	//Создает список минимальных путей 1 и список индексов путей 2 размером [2] из матрицы смежности [1]
	Floyd=(([1] * [2].cv * [2] * 1).CycleK * [2]);
	
	//арность 4->2
	//рассчитывает внешний цикл (по K) для матрицы смежности [1] размером [3] с промежуточным индексом K [4]
	//возвращает список минимальных путей 1 и список индексов путей 2
	CycleK=([4] * [3]).greater -> ([1] * [2]),
		(([1] * [2] * [3] * 1 * [4]).CycleI * [3] * ([4] * 1).add).CycleK;
	
	//арность 5->2
	//рассчитывает внутренний цикл (по I) для матрицы смежности [1] размером [3] начиная с индекса I [4] до индекса K [5]
	//возвращает список минимальных путей 1 и список индексов путей 2	
	CycleI = ([4] * [3]).greater -> ([1] * [2]),
		(([1] * [2] * [3] * [4] * 1 * [5]).CycleJ * [3] * ([4] * 1).add * [5]).CycleI;
		
	//арность 6->2
	//рассчитывает внутренний цикл (по J) для матрицы смежности [1] размером [3] начиная с индекса I [4] 
	//до индекса J [5] через индекс K [6]
	//возвращает список минимальных путей 1 и список индексов путей 2	
	CycleJ = ([5] * [3]).greater -> [1] * [2],
		(([1] * ([4] * [5]*[3]).IJ).getElem * (([1] * ([4] * [6]*[3]).IJ).getElem * ([1] * ([6] * [5]*[3]).IJ).getElem).add).greater -> 
		(([1] * (([1] * ([4] * [6]*[3]).IJ).getElem * ([1] * ([6] * [5]*[3]).IJ).getElem).add * ([4] * [5]*[3]).IJ).setElem * ([2] * [6] * ([4] * [5]*[3]).IJ).setElem * [3] * [4] * ([5] * 1).add * [6]).CycleJ,
		([1] * [2] * [3] * [4] * ([5] * 1).add * [6]).CycleJ;
	
	//арность 3->1
	//возвращает индекс элемента в списке по адресу [1] строка [2] столбец, [3] - размер
	IJ=(((([1] * 1).sub * [3]).mul * [2]).add);
	
	//арность 3>1
	//задает значение [2] элемента списка [1] с номером [3]
	setElem = ([1] * [2] * [3] * 1).set;
	
	//арность 4->1
	//вспомогательное задание значения [2] элемента списка [1] с номером [3]
	set = ([3] * [4]).equal -> ([2] * [1].~c_cons.[2]).c_cons,
		([1].~c_cons * [2] * [3] * [4]).([1] * ([2] * [3] * [4] * ([5] * 1).add).set).c_cons;
	
	//арность 2->1
	//берет элемент [2] из списка [1] и возвращает его
	getElem = ([1] * [2] * 1).get;
	
	//арность 3->1
	//вспомогательное извлечение элемента из списка [1] с номером [2]
	get = ([2] * [3]).equal -> [1].~c_cons.[1],
		([1].~c_cons.[2] * [2] * ([3] * 1).add).get;
	
	//арность 1->1
	//заполняет вектор 1 значениями [2] до длины [1]
	create_vector=([1] * 0 * 1).create_vector1;
	
	//арность 3->1
	//вспомогательное заполнение вектора 1 начальными значениями [3], [1] - размер вектора
	create_vector1 = ([1] * [2]).equal -> c_nil,
		([3] * ([1] * ([2] * 1).add * [3]).create_vector1).c_cons;
		
	//арность 1->1
	//создает вектор-матрицу, каждая строка которого, начиная с 1й, заполняется ее номером
	cv=([1] * 1 * 1 * 0).cv1;
	
	//арность 4->1
	//заполняет вектор-матрицу, [2] - номер строки, [3] - число заполнения, [4] - счетчик строк
	cv1 = ([1] * [4]).equal -> c_nil,
		([1] * [2]).greater -> ([3] * ([1] * ([2] * 1).add * [3] * [4]).cv1).c_cons,
		([3] * ([1] * 1 * ([3] * 1).add * ([4]*1).add).cv1).c_cons;
	
	//арность 1->2
	//читает из файла [1] в одномерный список (навигации i*size+j) 1 и возвращает size 2
	read=[1].readFile.readNumb.(([2] * ([1]*[1]).mul).read1 * [1]);

	//арность 2->
	//вспомогательное чтение строки [1] длиной [2]*[2] в строку 1
	read1=([1] * "").equal -> c_nil, (([1] * [2] * 0).readLine);
	
	//арность 3->2
	//считывает строку [1] в список 1, пока она не станет хранить [2] элементов
	//возвращает, если нужно или осталось хвост 2. [3] порядковый номер текущего элемента
    readLine = ([2] * [3]).equal -> c_nil * [1],
    (([1].readNumb * [2] * [3]).([1] * ([2] * [3] * ([4] * 1).add).readLine)).(([1] * [2]).c_cons * [3]);
	
	//арность 1->2
	//считывает число из строки [1] и возвращает остаток подстроки
	readNumb = ([1] * "[\\d]+").getToken.([1].toInt * [2]);
}

Application
% ShortestPath("./Tests/g5/g5.txt", 1, 3)