Некорректный вывод сообщения об ошибке.
	Data List['t]
	{
		List = c_nil ++ 't * List['t].c_cons;
	}
	Scheme QuickSort
	{
		@ = ~c_nil -> c_nil, 0;
	} 
	Application
	% QuickSort

Баги с областью видимости.
	Scheme Test
	{
		@ = Test1.print;	
		A = [1];	
		Fun Test1
		{
			@ = A * Test2;	// Видит А		
			Fun Test2
			{
				@ = A;		// Не видит А
			}
		}
	}
	Scheme Test
	{
		@ = F1(Func).print;
		Func = [1];	
		Fun F1[fFunction]
		{		
			@ = F2 * F3;		
			F2 = fFunction; 	// видит fFunction		
			Fun F3				
			{			
				@ = fFunction;	// не видит fFunction
			}
		}
	}

Некорректно работает print.
	[1] * print.print // выводит [1] * [1] , а должен [1]

Некорректно парсится цепочка условных композиций или некорректно выводится сообщение об ошибке.
	F1 = ([1] * 1).nequal -> ([1] * 2).nequal -> print, "cond1".print, "cond2".print;		// Не парсится
		// Выдаёт синтаксическую ошибку на позиции второй условной композиции.
	F2 = ([1] * 1).nequal -> (([1] * 2).nequal -> print, "cond1".print), "cond2".print;		// Работает
	
Операции над массивами изменяют входные данные, ломая тем самым парадигму функционального программирования.
    Create = (2*0).arrayCreate;
	@ = Create.(([1]*0*123).arraySet*([1]*1*456).arraySet).print;
	// [123,456]*[123,456]

Падает при попытке вычислений над пустым кортежем.
Некорректно отрабатывавет выбор из кортежа несуществующего элемента.
Некорректно выводятся сообщения о синтаксических ошибках.
Некорректно выводятся русские символы.
Состояние гонки при отмене упреждающих задач.
Out of memory в быстрой сортировке при подаче на вход обратно отсортированного списка длинной 2000 и более.
При попытке чтения не существующего файла выводится некорректная информация.
Передача делегата при рекурсивном вызове считается ошибкой.
Не освобождается память AST при синтаксической ошибке в бизоне.