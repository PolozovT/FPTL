#define _USE_MATH_DEFINES

#include <iostream>
#include <regex>
#include <fstream>
#include <iterator>
#include <random>
#include <filesystem>
#include <cmath>

#include <boost/thread/mutex.hpp>
#include <boost/thread/lock_guard.hpp>

#include "Macros.h"
#include "StandardLibrary.h"
#include "DataTypes/StringValue.h"
#include "DataTypes/ArrayValue.h"
#include "DataTypes/IntegerValue.h"
#include "DataTypes/BoolValue.h"
#include "DataTypes/DoubleValue.h"
#include "DataTypes/UndefinedValue.h"

namespace FPTL {
namespace Runtime {

namespace {

void id(SExecutionContext & aCtx)
{
	for (size_t i = 0; i < aCtx.argNum; ++i)
	{
		aCtx.push(aCtx.getArg(i));
	}
}

void tupleLength(SExecutionContext & aCtx)
{
	aCtx.push(IntegerValue(static_cast<int64_t>(aCtx.argNum)));
}

void Not(SExecutionContext & aCtx)
{
	const auto & arg = aCtx.getArg(0);
#if fptlDebugBuild
	if (arg.Type().typeName != BoolValue::staticTypeInfo.typeName)
		throw std::exception("Not a boolean value!");
#endif
	aCtx.push(BoolValue(!arg.ToBool()));
}

void And(SExecutionContext & aCtx)
{
	const auto & arg0 = aCtx.getArg(0);
	const auto & arg1 = aCtx.getArg(1);
#if fptlDebugBuild
	if (arg0.Type().typeName != BoolValue::staticTypeInfo.typeName ||
		arg1.Type().typeName != BoolValue::staticTypeInfo.typeName)
		throw std::exception("Not a boolean value!");
#endif
	aCtx.push(BoolValue(arg0.ToBool() && arg1.ToBool()));
}

void Or(SExecutionContext & aCtx)
{
	const auto & arg0 = aCtx.getArg(0);
	const auto & arg1 = aCtx.getArg(1);
#if fptlDebugBuild
	if (arg0.Type().typeName != BoolValue::staticTypeInfo.typeName ||
		arg1.Type().typeName != BoolValue::staticTypeInfo.typeName)
		throw std::exception("Not a boolean value!");
#endif
	aCtx.push(BoolValue(arg0.ToBool() || arg1.ToBool()));
}

void Xor (SExecutionContext & aCtx)
{
	const auto & arg0 = aCtx.getArg(0);
	const auto & arg1= aCtx.getArg(1);
#if fptlDebugBuild
	if (arg0.Type().typeName != BoolValue::staticTypeInfo.typeName ||
		arg1.Type().typeName != BoolValue::staticTypeInfo.typeName)
		throw std::exception("Not a boolean value!");
#endif
	aCtx.push(BoolValue(arg0.ToBool() ^ arg1.ToBool()));
}

void equal(SExecutionContext & aCtx)
{
	aCtx.push(BoolValue(aCtx.getArg(0).EqualTo(aCtx.getArg(1))));
}

void notEqual(SExecutionContext & aCtx)
{
	aCtx.push(BoolValue(!aCtx.getArg(0).EqualTo(aCtx.getArg(1))));
}

void greater(SExecutionContext & aCtx)
{
	aCtx.push(BoolValue(aCtx.getArg(0).GreaterThan(aCtx.getArg(1))));
}

void greaterOrEqual(SExecutionContext & aCtx)
{
	aCtx.push(BoolValue(!aCtx.getArg(0).LessThan(aCtx.getArg(1))));
}

void less(SExecutionContext & aCtx)
{
	aCtx.push(BoolValue(aCtx.getArg(0).LessThan(aCtx.getArg(1))));
}

void lessOrEqual(SExecutionContext & aCtx)
{
	aCtx.push(BoolValue(!aCtx.getArg(0).GreaterThan(aCtx.getArg(1))));
}

void add(SExecutionContext & aCtx)
{
	aCtx.push(aCtx.getArg(0) + aCtx.getArg(1));
}

void sub(SExecutionContext & aCtx)
{
	aCtx.push(aCtx.getArg(0) - aCtx.getArg(1));
}

void mul(SExecutionContext & aCtx)
{
	aCtx.push(aCtx.getArg(0) * aCtx.getArg(1));
}

void div(SExecutionContext & aCtx)
{
	aCtx.push(aCtx.getArg(0) / aCtx.getArg(1));
}

void mod(SExecutionContext & aCtx)
{
	aCtx.push(aCtx.getArg(0) % aCtx.getArg(1));
}

// Генерирует случайное вещественное число в диапазоне от 0 до 1.
void rand(SExecutionContext & aCtx)
{
	static thread_local std::random_device rd;
	static thread_local std::mt19937_64 gen(rd());
	static std::uniform_real_distribution realDistrib;
	aCtx.push(DoubleValue(realDistrib(gen)));
}

void sqrt(SExecutionContext & aCtx)
{
	aCtx.push(DoubleValue(std::sqrt(aCtx.getArg(0).ToDouble())));
}

void sin(SExecutionContext & aCtx)
{
	aCtx.push(DoubleValue(std::sin(aCtx.getArg(0).ToDouble())));
}

void cos(SExecutionContext & aCtx)
{
	const auto & arg = aCtx.getArg(0);
	aCtx.push(DoubleValue(std::cos(aCtx.getArg(0).ToDouble())));
}

void tan(SExecutionContext & aCtx)
{
	const auto & arg = aCtx.getArg(0);
	aCtx.push(DoubleValue(std::tan(aCtx.getArg(0).ToDouble())));
}

void asin(SExecutionContext & aCtx)
{
	const auto & arg = aCtx.getArg(0);
	aCtx.push(DoubleValue(std::asin(aCtx.getArg(0).ToDouble())));
}

void atan(SExecutionContext & aCtx)
{
	const auto & arg = aCtx.getArg(0);
	aCtx.push(DoubleValue(std::atan(aCtx.getArg(0).ToDouble())));
}

void round(SExecutionContext & aCtx)
{
	const auto & arg = aCtx.getArg(0);
	aCtx.push(DoubleValue(std::floor(aCtx.getArg(0).ToDouble() + 0.5)));
}

void log(SExecutionContext & aCtx)
{
	const auto & arg = aCtx.getArg(0);
	aCtx.push(DoubleValue(std::log(aCtx.getArg(0).ToDouble())));
}

void exp(SExecutionContext & aCtx)
{
	const auto & arg = aCtx.getArg(0);
	aCtx.push(DoubleValue(std::exp(aCtx.getArg(0).ToDouble())));
}

void loadPi(SExecutionContext & aCtx)
{
	aCtx.push(DoubleValue(M_PI));
}

void loadE(SExecutionContext & aCtx)
{
	aCtx.push(DoubleValue(M_E));
}

void abs(SExecutionContext & aCtx)
{
	const auto & arg = aCtx.getArg(0);
	aCtx.push(aCtx.getArg(0).Abs());
}

void print(const SExecutionContext & aCtx)
{
	static boost::mutex outputMutex;
	boost::lock_guard<boost::mutex> guard(outputMutex);

	aCtx.print(std::cout);
}

void printType(const SExecutionContext & aCtx)
{
	static boost::mutex outputMutex;
	boost::lock_guard<boost::mutex> guard(outputMutex);

	aCtx.printTypes(std::cout);
}

// Преобразование в строку.
void toString(SExecutionContext & aCtx)
{
	std::stringstream strStream;
	aCtx.getArg(0).Print(strStream);
	aCtx.push(StringValue(strStream.str()));
}

// Преобразование в вещественное число.
void toInteger(SExecutionContext & aCtx)
{
	aCtx.push(IntegerValue(aCtx.getArg(0).ToInt()));
}

// Преобразование в целое число.
void toDouble(SExecutionContext & aCtx)
{
	aCtx.push(DoubleValue(aCtx.getArg(0).ToDouble()));
}

// Конкатенация строк.
void concat(SExecutionContext & aCtx)
{
	std::stringstream strStream;

	for (size_t i = 0; i < aCtx.argNum; ++i)
	{
		const auto & arg = aCtx.getArg(i);

#if fptlDebugBuild
		if (arg.Type().typeName != StringValue::staticTypeInfo.typeName)
			throw std::exception("Not a string value!");
#endif
		aCtx.getArg(0).Print(strStream);
	}

	aCtx.push(StringValue(strStream.str()));
}

// Длина строки.
void length(SExecutionContext & aCtx)
{
	const auto & arg = aCtx.getArg(0);

#if fptlDebugBuild
	if (arg.Type().typeName != StringValue::staticTypeInfo.typeName)
		throw std::exception("Not a string value!");
#endif

	aCtx.push(IntegerValue(static_cast<int64_t>(arg.Length())));
}

// Поиск по регулярному выражению.
void search(SExecutionContext & aCtx)
{
	const auto & arg0 = aCtx.getArg(0);
	const auto & arg1 = aCtx.getArg(1);

#if fptlDebugBuild
	if (arg0.Type().typeName != StringValue::staticTypeInfo.typeName ||
		arg1.Type().typeName != StringValue::staticTypeInfo.typeName)
		throw std::exception("Not a string value!");
#endif

	std::stringstream strStream;
	aCtx.getArg(0).Print(strStream);
	const auto& src = strStream.str();
	
	strStream.clear();
	aCtx.getArg(1).Print(strStream);
	std::regex rx(strStream.str());

	std::smatch matchResults;

	if (std::regex_search(src, matchResults, rx))
	{
			const auto& prefix = StringValue(matchResults.prefix());
			aCtx.push(prefix);
			const auto& suffix = StringValue(matchResults.suffix());
			aCtx.push(suffix);
			for (size_t i = 0; i < rx.mark_count(); ++i)
			{
				const auto& m = matchResults[i + 1];
				const auto& val = StringValue(src);
				aCtx.push(val);
			}
	}
	else
	{
		aCtx.push(UndefinedValue());
	}
}

// Проверка соответствия по регулярному выражению.
void match(SExecutionContext & aCtx)
{
	const auto & arg0 = aCtx.getArg(0);
	const auto & arg1 = aCtx.getArg(1);

#if fptlDebugBuild
	if (arg0.Type().typeName != StringValue::staticTypeInfo.typeName ||
		arg1.Type().typeName != StringValue::staticTypeInfo.typeName)
		throw std::exception("Not a string value!");
#endif

	std::stringstream strStream;
	aCtx.getArg(0).Print(strStream);
	const auto& src = strStream.str();

	strStream.clear();
	aCtx.getArg(1).Print(strStream);
	std::regex rx(strStream.str());

	std::smatch matchResults;

	if (std::regex_match(src, matchResults, rx))
	{
		for (size_t i = 0; i < rx.mark_count(); ++i)
		{
			const auto& m = matchResults[i+1];
			const auto& val = StringValue(src);
			aCtx.push(val);
		}
	}
	else
	{
		aCtx.push(UndefinedValue());
	}
}

// Замена по регулярному выражению.
void replace(SExecutionContext & aCtx)
{
	const auto & arg0 = aCtx.getArg(0);
	const auto & arg1 = aCtx.getArg(1);
	const auto & arg2 = aCtx.getArg(2);

#if fptlDebugBuild
	if (arg0.Type().typeName != StringValue::staticTypeInfo.typeName ||
		arg1.Type().typeName != StringValue::staticTypeInfo.typeName ||
		arg2.Type().typeName != StringValue::staticTypeInfo.typeName)
		throw std::exception("Not a string value!");
#endif

	std::stringstream strStream;
	aCtx.getArg(0).Print(strStream);
	const auto& src = strStream.str();

	strStream.clear();
	aCtx.getArg(1).Print(strStream);
	std::regex rx(strStream.str());

	strStream.clear();
	aCtx.getArg(2).Print(strStream);
	const auto& replacement = strStream.str();

	const auto& result = std::regex_replace(src, rx, replacement);
	aCtx.push(StringValue(result));
}

// Выделение лексемы с начала строки.
void getToken(SExecutionContext & aCtx)
{
	const auto & arg0 = aCtx.getArg(0);
	const auto & arg1 = aCtx.getArg(1);

	const auto src = arg0.getOps()->toString(arg0);
	const auto pattern = arg1.getOps()->toString(arg1);

	const std::regex rx("^(?:\\s*)(" + pattern->str() + ")");

	std::cmatch matchResults;

	const auto first = static_cast<const char *>(src->getChars());
	const auto last = static_cast<const char *>(src->getChars() + src->length());

	if (std::regex_search(first, last, matchResults, rx))
	{
		const auto prefix = StringBuilder::create(aCtx, src, matchResults[1].first - src->contents(), matchResults[1].second - src->contents());
		aCtx.push(prefix);

		const auto suffix = StringBuilder::create(aCtx, src, matchResults.suffix().first - src->contents(), matchResults.suffix().second - src->contents());
		aCtx.push(suffix);
	}
	else
	{
		aCtx.push(DataBuilders::createUndefinedValue());
	}
}

// Чтение содержимого файла.
void readFile(SExecutionContext & aCtx)
{
	// Проверяем имя файла.
	const auto & arg = aCtx.getArg(0);

	const auto fileName = arg.getOps()->toString(arg);

	std::ifstream input;
	input.open(fileName->str());
	if (input.is_open())
	{
		// Вычисляем размер файла.
		const auto begin = input.tellg();
		input.seekg(0, std::ios::end);
		const auto size = input.tellg() - begin;
		input.seekg(0, std::ios::beg);

		// Резервируем память под файл.
		const auto val = StringBuilder::create(aCtx, size);
		// Читаем данные.
		std::copy(std::istreambuf_iterator<char>(input), std::istreambuf_iterator<char>(), val.mString->getChars());
		aCtx.push(val);
	}
	else
	{
		aCtx.push(DataBuilders::createUndefinedValue());
	}
}

void writeToFile(SExecutionContext & aCtx, std::ios::openmode mode)
{
	// Проверяем имя файла.
	const auto & val = aCtx.getArg(0);
	const auto & file = aCtx.getArg(1);

	const auto fileName = file.getOps()->toString(file);

	if (exists(std::filesystem::status(fileName->str())))
	{
		permissions(fileName->str(),
			std::filesystem::perms::owner_all | std::filesystem::perms::group_all,
			std::filesystem::perm_options::add);
	}
	std::ofstream output(fileName->str(), mode);
	output.precision(std::numeric_limits<double>::max_digits10);
	if (output.is_open())
	{
		val.getOps()->write(val, output);
		aCtx.push(DataBuilders::createBoolean(true));
	}
	else
	{
		aCtx.push(DataBuilders::createBoolean(false));
	}
}

// Создание или перезапись файла.
void createFile(SExecutionContext & aCtx)
{
	writeToFile(aCtx, std::ios::out);
}

// Запись в конец файла.
void appendFile(SExecutionContext & aCtx)
{
	writeToFile(aCtx, std::ios::app);
}

// Создание массива.
void createArray(SExecutionContext & aCtx)
{
	const auto sizeVal = aCtx.getArg(0).getOps()->toInt(aCtx.getArg(0));
	const auto & initialVal = aCtx.getArg(1);

	if (sizeVal <= 0) throw std::invalid_argument("The size of the array must be greater than zero!");

	const auto size = static_cast<size_t>(sizeVal);
	aCtx.push(ArrayValue::create(aCtx, size, initialVal));
}

// Чтение элемента из массива.
void getArrayElement(SExecutionContext & aCtx)
{
	const auto & arrVal = aCtx.getArg(0);
	const auto & posVal = aCtx.getArg(1);

	ArrayValue::arrayValueCheck(arrVal);
	const size_t pos = posVal.getOps()->toInt(posVal);

	aCtx.push(ArrayValue::get(arrVal, pos));
}

// Запись элемента в массив.
void setArrayElement(SExecutionContext & aCtx)
{
	const auto & arrVal = aCtx.getArg(0);
	const auto & posVal = aCtx.getArg(1);
	const auto & val = aCtx.getArg(2);

	ArrayValue::arrayValueCheck(arrVal);
	const size_t pos = posVal.getOps()->toInt(posVal);

	ArrayValue::set(const_cast<DataValue &>(arrVal), pos, val);

	aCtx.push(arrVal);
}

void getArrayLength(SExecutionContext & aCtx)
{
	const auto & arrVal = aCtx.getArg(0);
	ArrayValue::arrayValueCheck(arrVal);
	aCtx.push(DataBuilders::createInt(ArrayValue::getLen(arrVal)));
}

void ArrayConcat(SExecutionContext & aCtx)
{
	aCtx.push(ArrayValue::concat(aCtx));
}

void ArrayCopy(SExecutionContext & aCtx)
{
	const auto & arrVal = aCtx.getArg(0);
	ArrayValue::arrayValueCheck(arrVal);
	aCtx.push(ArrayValue::copy(aCtx, arrVal));
}

void ArrayDot(SExecutionContext & aCtx)
{
	const auto & arrVal1 = aCtx.getArg(0);
	const auto & arrVal2 = aCtx.getArg(1);
	ArrayValue::arrayValueCheck(arrVal1);
	ArrayValue::arrayValueCheck(arrVal2);
	aCtx.push(ArrayValue::dot(aCtx, arrVal1, arrVal2));
}

// Запись элемента в массив.
void arrayFromFile(SExecutionContext & aCtx)
{
	auto arrVal = aCtx.getArg(0);
	const auto fileVal = aCtx.getArg(1);

	ArrayValue::arrayValueCheck(arrVal);
	const auto fileName = fileVal.getOps()->toString(fileVal);

	std::ifstream input(fileName->str());
	if (input.is_open())
	{
		ArrayValue::fromString(arrVal, static_cast<std::istream&>(input));
		aCtx.push(arrVal);
	}
	else
	{
		aCtx.push(DataBuilders::createUndefinedValue());
	}
}

} // anonymous namespace

const std::map<std::string, TFunction> StandardLibrary::mFunctions =
{
	// Работа с кортежем.
	{"id", &id},
	{"tupleLen", &tupleLength},

	// Арифметические.
	{"add",&add},
	{"sub", &sub},
	{"mul", &mul},
	{"div", &div},
	{"mod", &mod},
	{"abs", &abs},
	{"sqrt", &sqrt},
	{"exp", &exp},
	{"ln", &log},
	{"round", &round},
	{"sin", &sin},
	{"cos", &cos},
	{"tan", &tan},
	{"asin", &asin},
	{"atan", &atan},
	{"Pi", &loadPi},
	{"E", &loadE},
	{"rand", &rand},

	//Логические.
	{"not", &Not},
	{"and", &And},
	{"or", &Or },
	{"xor", &Xor },
	{"equal", &equal},
	{"nequal", &notEqual},
	{"greater", &greater},
	{"gequal", &greaterOrEqual},
	{"less", &less},
	{"lequal", &lessOrEqual},

	// Работа со строками.
	{"length", &length},
	{"cat", &concat},
	{"search", &search},
	{"replace", &replace},
	{"match", &match},
	{"getToken", &getToken},

	// Преобразования типов.
	{"toInt", &toInteger},
	{"toReal", &toDouble},
	{"toString", &toString},

	// Ввод / вывод.
	{"print", &print},
	{"printType", &printType},
	{"readFile", &readFile},
	{"createFile", &createFile},
	{"appendFile", &appendFile},

	// Работа с массивами.
	{"arrayCreate", &createArray},
	{"arrayGet", &getArrayElement},
	{"arraySet", &setArrayElement},
	{"arrayLen", &getArrayLength},
	{"arrayCat", &ArrayConcat},
	{"arrayCopy", &ArrayCopy},
	{"ArrayDot", &ArrayDot},
	{"arrayFromFile", &arrayFromFile}
};

StandardLibrary::StandardLibrary() : FunctionLibrary("StdLib")
{
	addFunctions(mFunctions);
}

}} // FPTL::Runtime
